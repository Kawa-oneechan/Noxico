<code-block>	::=	<statement>
		|	<statement> <code-block>

<statement>	::=	<command> \n
		|	<id> . <command> \n
		|	me. <command> \n
		|	<msg-command>
		|	<if-block>
		|	<for-block>
		|	<word> :
		|	<variable> = <expression>

<msg-command>	::=	| <message>
		|	! <message>
		|	? <message>
<message>	::=	<< words words words words >>

<if-block>	::=	if <if-check> \n <code-block> endif
<if-check>	::=	<variable> <if-comparison> <value>
		|	exists
		|	set
		|	not exists
		|	not set
<if-comparsion>	::=	==
		|	!=
		|	<=
		|	>=
		|	<
		|	>

<for-block>	::=	for <for-define> \n <code-block> \n next
<for-define>	::=	<value> to <value> as <variable>
		|	<value> to <value>
		|	<value> to <value> step <value>
		|	<value> to <value> step <value> as <variable>
/* Examples:
 * for 65 to 90
 * 	char it
 *	wait 3
 * next
 * for 10 to 0 step -1 as foo
 * 	char foo
 *	wait 3
 * next
 */

<path>		::=	<token>
		|	<token> \ <path>

<id>		::=	<word>
<token>		::=	<word>
<variable>	::=	<word>
		|	it
<value>		::=	<number>
		|	<variable>
<character>	::=	' <char> '
		|	<number>
<direction>	::=	north
		|	south
		|	west
		|	east
		|	up
		|	down
		|	left
		|	right
		|	flow

/* Undefined assumptions
 * ---------------------
 * Integral types can be specified as decimal "42" or hex "0x2A".
 * Specifying a float value where an int is expected lops it off (1.5 -> 1).
 * Floats can only be specified as decimal, be it "42" or "42.1". No commas.
 * Characters can be specified as hex "0x42" or as a character literal "'B'".
 * Anywhere a number is expected, a variable can be substituted, including it.
 * A word is just that - a single word like "foobar". No punctuation but '_',
 * can contain numbers but not start with them.
 * IDs refer to entities with their ID property set.
 * Commands that affect an entity that don't have any target specified (ie:
 * "move up") assume it's "me" (the entity currently executing its script).
 * You can also refer to "player", by virtue of the player simply having
 * that ID.
 * The meta-variable "it" is set by a bunch of commands and is always
 * available.
 * "Exists" and "set" are also set by certain commands.
 * Expressions are just that, and are parsed on the fly in a shunting yard.
 *
 * Specifics
 * ---------
 * "|<<" starts a block of text to display in a scroller. The text ends at the
 * first ">>" and can have variable expansion. Text is automatically wrapped.
 * "!<<" is mostly the same but displays the text in a non-scrolling message
 * box, while "?<<" does the same with a "yes/no" prompt. In that case, the
 * answer is stored in set.
 * Once one "<<" of any style is found, any others of the same style that
 * follow are placed in the same buffer, splitting up at anything that
 * interrupts execution -- go, restart, end, wait, if set, or "[end]"
 * There are two different expansions: [grammar], <$vars> and <@paths>.
 * Here's an example to cover grammers and paths:
 *
 * |<< As you watch [firstname] undress, you notice that [he] has a a large
 *     patch of pubic hair topping [his] crotch, the same <@hair\color> as
 *     on [his] head. >>
 * checktag penis
 * if exists
 *	|<< [firstname] takes notice of your noticing and grows erect. >>
 * endif
 * |<< [break]It all looks pretty damn exciting, is what I'm saying here.
 *     [end] >>
 *
 * End result could be like this:
 * +--------------------------| Thora Zekdurozmo |-------------------------+
 * | As you watch Thora undress, you notice that shi has a large patch of  |
 * | pubic hair topping hir crotch, the same red as on hir head. Thora     |
 * | takes notice of your noticing and grows erect.                        |
 * |                                                                       |
 * | It all looks pretty damn exciting, is what I'm saying here.           |
 * +---------------------------------------------------------------| \/ |--+
 *
 * And here's an example for variables:
 *
 * for 1 to 10
 *	!<< <$it>... >>
 * next
 * !<< [break]...ready or not, here I come!
 *
 * Resuls in "1... 2... 3... 4... 5... 6... 7... 8... 9... 10... ...ready or
 * not, here I come!"
 *
 * To display []<> or even >> in the middle of a text block, use the <g>
 * display tag: << The display reads:[break] 4 <g3E><g3E> 1 = 2; >>
 * This is not part of the scripting engine but of the Write function --
 * <gXX[,YY]> displays arbitrary glyph XX, and possibly an ExTile YY, both
 * in hex, <b> toggles the intensity of the foreground color, and <cXX[,YY]>
 * sets the foreground color to XX and possibly the background color to YY,
 * both specified in decimal. Just <c> resets to silver on black (0x07).
 * Scripts only run in Walkabout mode so displaying and waiting for the
 * message box automatically halts all the scripts on the board, preventing
 * premature display of more messages.
 *
 * An example of expressions and variable assignments:
 * meaningOfLife = 42
 * if meaningOfLife != 42
 * 	!<< There is something fundamentally wrong with the universe. >>
 * endif
 * halfLife = meaningOfLife / 2
 * kawaAge = 2011 - 1983
 * !<< Kawa is <$kawaAge> years old. >>
 *
 * Expressions can be basically anything that Cynthia's $calc command
 * supports, with added variables. Though a variable can have the same
 * name as a function, --the functions take precedence-- so if you do
 * 	pow = 9001
 *	kaioKen = pow(powerLevel, 2)
 * you cannot use the pow variable in an expression, as pow(x, y) is also
 * the name of a function. Instead, call the variable something else:
 *	powerLevel = 9001
 *	kaioKen = pow(powerLevel, 2)
 * It can be assigned to just the same, being just another variable.
 *	it = 1337
 * Variables are all GLOBAL in scope! Entities are updated in order of
 * definition and their scripts run as part of the same update, so if
 * entity #4 sets foo to 10, entity #5 can then refer to foo and get
 * that same 10 back. However, you should NOT assume the entities are
 * updated in a certain order. Always initialize an entity's variables
 * before use, and if you need to retain them locally, stuff them in a
 * tag:
 *	vegeta.settagval localvars\powerlevel powerlevel
 * Then, to retrieve the value in the next update:
 *	vegeta.gettagval localvars\powerlevel
 *	powerlevel = it
 */
 
/*
 
 COMMAND LIST
 ------------

char <character>
	Sets the glyph used to render the target character.
		char '@'
		me.char 4
		todd.char 0x02

color <color name> [<color name>]
OR    <R> <G> <B> [<R> <G> <B>]
		color red black
		me.color yellow
		todd.color 42 0 69 16 16 16

wait <number>
	(EOC) Delays further script execution until the specified
	amount of cycles have passed. The amount is truncated to
	integer, and the command can only be used on the currently
	executing character.
		wait 10
		me.wait 5.5 -- waits for 5.0 cycles instead.
		-- but NOT todd.wait 10 if this is not Todd.

go <direction>
	(EOC) Attempts to move the target character in the specified
	direction. If the direction specified is "flow", the target
	continues to move in their previous direction, which defaults
	to south.
		go up
		me.go flow
		todd.go up
		-- if this IS Todd, he'll try to move up three spaces.

find <value> <value>
	(EOC) Attempts to find and follow a path to an arbitrary
	location on the board. Execution is halted until the character
	reaches their destination. If there is no path, "exists" is
	set to false and execution continues unhindered. This quite
	obviously means that if there IS a path, "exists" is set to
	true, but you don't get to act on that until you're there.
		find 10 40
		todd.find X Y

transport <value> <value>
	(EOC) Instantly places the target character in the specified
	location, no matter if it's solid or whatever.

immolate
	(EOC) Spontaneously combusts the target character, possibly
	causing nearby flammable materials to catch on fire as well.
	This pretty much kills the character.

die
	(EOC) Removes the target character from play entirely.

gib
	(EOC) Removes the target character from play, but leaves
	(most of) their stuff and a bunch of gibs behind.

repeat
	Restarts execution from line one.

end
	(EOC) Stops execution until something triggers a label.

goto <word>
	Finds the first label with the specified name and resumes
	execution from there.
		foo:
			goto grill
		bar:
			-- this is never done.
		grill:
			-- this is.

checktag <path>
	Determines if the tag on the specified path exists and
	sets "exists" accordingly.
		player.checktag "breastrow/nipples/fuckable"
		if exists
			!<< She gazes at your mutant nipples with a mix
			    of fear and intrigue... >>
		endif

addtag [<path>] <word>
	Adds a tag to the specified path, if one is specified, or to the root.
	
replacetag <path> <word>
	If the tag on the specified path exists, replaces that with another,
	removing all the child tags in the process.
		replacetag "ears/human" "cat"

renametag <path> <word>
	If the tag on the specified path exists, replaces that with another,
	but leaving all the child tags intact.
		renametag "skin" "fur"

removetag [<path>] <word>
	If the tag on the specified path exists, removes it entirely.
		removetag "balls" -- ouch.

settagval <path> <value>
	If the tag on the specified path exists, sets its float value to the
	one given.

gettagval <path>
	If the tag on the specified path exists, sets the "it" variable to
	that tag's float value.

inctagval <path> [<value>]
	If the tag on the specified path exists, increases its float value by
	the specified amount. If no amount is given (that is, the <value> is
	left out, NOT that it is equal to 0.0), it's increased by 1.

dectagval <path> [<value>]
	If the tag on the specified path exists, decreases its float value by
	the specified amount. If no amount is given, it's decreased by 1.


 		|	checkplot <word>
 		|	setplot <word>
 		|	resetplot <word>
 		|	growpenis <value> <value>
 		|	shrinkpenis <value>
 		|	growbreasts <TO BE DEFINED>
 		|	shrinkbreasts <TO BE DEFINED>
		|	...//TODO
*/