<!DOCTYPE HTML>
<html>
	<head>
		<title>Noxico planfile</title>
		<meta charset="UTF-8" />
		<style type="text/css">
			body
			{
				font-family: "Century Schoolbook", "Times New Roman", serif;
				background: rgb(31,31,31);
				color: rgb(127,159,127);
				width: 90%;
				margin: 1em 2em;
			}
			h1, h2, h3, h4 { font-family: "Century Schoolbook", "Times New Roman", serif; }
			body, h2, h3, h4 { color: rgb(177,209,177); }
			samp
			{
				/* MSPA, yes. */
				font-family: "Courier", monospace;
				font-weight: 700;
			}
			h1
			{
				text-shadow: 2px 2px 0px #000;
				color: rgb(220,220,204);
			}
			h1, h2 { border-bottom: 2px solid rgb(63,63,63); }

			a:link { color: rgb(204,204,142); }
			a:visited { color: rgb(134,134,72); }
			a:hover { color: rgb(255,255,255); }
			table
			{
				background: black;
				border-spacing: 1px;
				margin: 0.5em;
			}
			td
			{
				background: rgb(53,53,53);
				color: rgb(220,220,204);
				padding: 0 4px;
			}
			th
			{
				background: rgb(26,47,44);
				color: rgb(127,159,127);
				text-shadow: 1px 1px 0px #000;
			}
			.math, .math td
			{
				background: inherit;
				color: inherit;
				text-align: center;
				cursor: help;
			}
			.math td.frac
			{
				border-bottom: 1px solid;
			}
			#mapmockup td
			{
				width: 24px;
				height: 24px;
				padding: 0px;
				text-align: center;
				vertical-align: middle;
				font-family: "Courier New";
				font-weight: bold;
				font-size: 19px;
				color: black;
			}
			#mapmockup .gr { background: #C2D69B; }
			#mapmockup .de { background: #C4BC96; }
			#mapmockup .sn { background: #F2F2F2; }
			#mapmockup .sw { background: #CCC0D9; }

			.done { color: rgb(107,179,107); }
			.done:before
			{
				content: '\2714';
				color: rgb(107,179,107);;
			}
			.scratched { color: rgb(177,109,107); }
			.scratched:before
			{
				content: '\2718';
				color: rgb(177,109,107);
			}
			.new
			{
				background: rgb(71,71,71);
				color: rgb(157,189,157);
			}
			.new:before
			{
				content: 'NEW: ';
				color: rgb(197,229,197);
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<h1>Noxico planfile</h1>
		<p>So yeah, this used to be a plaintext file. Screw that noise, I'm bored and this looks better!</p>
		<h2>Contents</h2>
		<ul>
			<li><a href="#suggest">Suggestions</a></li>
			<li><a href="#actions">Actions</a></li>
			<li><a href="#morph">Morph lines</a></li>
			<li><a href="#charval">Character values</a></li>
			<li><a href="#base">Home base</a></li>
			<li><a href="#items">Items</a></li>
			<li><a href="#gen">World generation</a></li>
			<li><a href="#save">Saving and Loading</a></li>
			<li><a href="#units">Units of Measurement</a></li>
		</ul>
		<p>Last update: February 3rd 2012, 16:21 &mdash; added colorcoding and updated map format.</p>

		<h2 id="suggest">Suggestions</h2>
		<h3>From Emuz</h3>
		<ul>
			<li class="done">desert, snow, and swamp areas</li>
			<li>tombstones</li>
		</ul>
		<h3>From others</h3>
		<ul>
			<li>googlegirls
				<ul>
					<li>Like goo girls, but special in some ways (to be determined) and very hard to find.</li>
				</ul>
			</li>
		</ul>

		<h2 id="actions">Actions</h2>
		<h3>Walkabout mode</h3>
		<dl>
			<dt><b>F</b>ly</dt>
			<dd>If you have functional wings, hover in place to render fences, people and other things that aren't walls passable. Or if you're already flying, drop down again.</dd>
			<dt><b>I</b>tems</dt>
			<dd class="done">Open the inventory screen.</dd>
			<dt><b>L</b>ook</dt>
			<dd class="done">Get details on anything on the board. This is the same thing as a right-click or <kbd>/<kbd></dd>
			<dt>Pick Up</dt>
			<dd>Take an item within a 3x3 grid around. Key is not <kbd>P<kbd>, but <kbd>,</kbd>.
			<dt><b>C</b>hat</dt>
			<dd>Engage a nearby (distance less than five tiles) character in talks. This might result in shenanigans.</dd>
		</dl>
		<h3>Shenanigans</h3>
		<p>
			Shenanigans involving the player are done turn-based, as opposed to quasi real-time when both participants are NPCs. You get a bunch of descriptive text lines, followed by one or more possible actions, depending on various contexts.
		</p>

		<h2 id="morph">Morph lines</h2>
		<p>
			Items and other causes (to be determined) may cause a character to change form in some way. Here are some different lines that can be followed. In these lines, "anthro limit" means two things: if there's two separate items, one will go further; if there's only one this would be an excellent time to stop and consider. "Any time" means that any time the item is used, there's a reasonably high chance of that specific effect happening.
		</p>
		<h3>Cat</h3>
		<ol>
			<li>Raise speed (any time)</li>
			<li>Raise charisma (most any time)</li>
			<li>Grow small triangular ears</li>
			<li>Grow a cat tail</li>
			<li>Grow fangs (anthro limit)</li>
			<li>Grow fur</li>
			<li>Grow digitigrade legs</li>
			<li>Grow up to two extra breast rows</li>
		</ol>
		<h3>Dog</h3>
		<ol>
			<li>Raise strength (any time)</li>
			<li>Grow big triangular ears</li>
			<li>Grow a dog tail</li>
			<li>Grow fangs (anthro limit)</li>
			<li>Grow fur</li>
			<li>Grow digitigrade legs</li>
			<li>Grow up to two extra breast rows</li>
		</ol>
		<h3>Fox</h3>
		<ol>
			<li>Raise cunning (any time)</li>
			<li>Raise charisma (most any time)</li>
			<li>Grow big triangular ears</li>
			<li>Grow a fox tail</li>
			<li>Grow fangs (anthro limit)</li>
			<li>Grow fur</li>
			<li>Grow digitigrade legs</li>
		</ol>
		<h3>Bunny</h3>
		<ol>
			<li>Raise libido (any time)</li>
			<li>Grow long floppy ears</li>
			<li>Grow a bunny tail (anthro limit)</li>
			<li>Grow fur</li>
		</ol>
		<h3>Slime</h3>
		<ol>
			<li>Raise sensitivity (any time)</li>
			<li>Lower cunning (most any time)</li>
			<li>Goop out hair</li>
			<li>Goop out wings, if present</li>
			<li>Goop out the body</li>
			<li>Goop out genitals, if present</li>
			<li>Replace legs with an amorphous blob</li>
		</ol>
		<h3>Naga</h3>
		<ol>
			<li>Raise cunning? (any time)</li>
			<li>Grow fangs</li>
			<li>Grow a snake-like lower body</li>
			<li>Grow scales (rarely)</li>
		</ol>
		<h3>Succubus</h3>
		<ol>
			<li>Raise libido (any time)</li>
			<li>Raise charisma (most any time)</li>
			<li>Shrink cock(s) (any time)</li>
			<li>Grow (bigger) tits (any time)</li>
			<li>At random
				<ol>
					<li>Grow a vagina</li>
					<li>Grow small horns</li>
					<li>Grow fangs?</li>
					<li>Grow claws?</li>
					<li>Grow bat wings</li>
					<li>Grow bigger horns?</li>
					<li>Lubricate</li>
					<li>Become a squirter</li>
				</ol>
			</li>
		</ol>
		<h3>Incubus</h3>
		<ol>
			<li>Raise libido (any time)</li>
			<li>Raise strength (any time)</li>
			<li>Grow (bigger) cock(s) (any time)</li>
			<li>Shrink tits (any time)</li>
			<li>Shrink vagina (any time)</li>
			<li>At random
				<ol>
					<li>Grow small horns</li>
					<li>Demonize cock</li>
					<li>Grow fangs?</li>
					<li>Grow claws?</li>
					<li>Grow bat wings</li>
					<li>Grow bigger horns?</li>
					<li>Lubricate</li>
					<li>Grow an extra cock</li>
				</ol>
			</li>
		</ol>
		<p>
			All we need now are a line for cow-like beings and something or things to justify feathery wings.
		</p>

		<h2 id="charval">Character values</h2>
		<h3>Basic Stats</h3>
		<p>Every good RPG has to have these.</p>
		<table>
			<tr><th>Name</th><th>Acronym</th><th>Description</th></tr>
			<tr><td>Charisma</td><td>CHA</td><td>How likely other characters are to talk to you and engage in shenanigans.</td></tr>
			<tr><td>Climax</td><td>CLI</td><td>Obvious.</td></tr>
			<tr><td>Cunning</td><td>CUN</td><td>How well you can make other characters agree to your whims (verbal skill, works with charisma), and how well you can find stuff.</td></tr>
			<tr><td>Carnality</td><td>CAR</td><td>How fast your stimulation rises over time, compounded by other characters being nearby. Used to be Libido.</td></tr>
			<tr><td>Stimulation</td><td>STI</td><td>Obvious. Used to be excitement.</td></tr>
			<tr><td>Sensitivity</td><td>SEN</td><td>How likely it is your stimulation and climax will rise when touched.</td></tr>
			<tr><td>Speed</td><td>SPD</td><td>Determines order of movement in shenanigans, and affects dodge chances.</td></tr>
			<tr><td>Strength</td><td>STR</td><td>Determines maximum carrying weight, bare-handed attack strength, and success chance of trying to become the dominant partner.</td></tr>
		</table>
		<p>
			<s>I like how there's three that start with S and three with C, and feel like getting a thesaurus to replace "Excitement" and "Libido" with similar words. In fact, I'm kinda reminded of Andrew Hussie and his endless array of A-verbs. According to Word 2010's thesaurus function, "excitement" could be "stimulation", but "libido" gives no results. I'll try again when I'm online and update this paragraph then.</s>
		</p>
		<h3>Skill levels</h3>
		<p>
			These might be interesting to add. For certain things with a more or less random chance of occurring, these might fudge the chance in favor. Other things that always happen might get a bonus. For example, imagine a character with a skill of 0 in Blowjobs. They give a blowjob to another character, who gets a minimal increase in Stimulation from it. As the character's Blowjobs skill increases, the recipient's Stimulation rises with higher increases to reflect the 1337 manouvres at work.
		</p>
		<p>
			When doing something related to a skill (or more than one), the float value of that skill is increased by a certain value, whereas the actual skill level being checked is the integral portion. What exactly this increase value is is directly related to the skill level:
		</p>
		<table class="math" title="increase = 0.20 / ( 1 + ( (int)level / 2 ) )">
			<tr>
				<td rowspan="3">
					<var>i</var> =&nbsp;
				</td>
				<td colspan="2" class="frac">
					0.20
				</td>
			</tr>
			<tr>
				<td rowspan="2">
					1 +&nbsp;
				</td>
				<td class="frac">
					(int)<var>l</var>
				</td>
			</tr>
			<tr>
				<td>
					2
				</td>
			</tr>
		</table>
		<p>
			That way, the increase when the skill level is 0 would be 0.20, meaning you need to do that thing five times to reach skill level 1. Then, the increase lowers to 0.13, meaning you need to do it eight times for skill level 2, with a bit of carry-over. The increase then lowers to 0.10, so you need to do it ten times for level 3. Then it's 0.08, etcetera, until about level 10 gives only 0.03 points per time.
		</p>
		<p>Skills could be anything, really, being just another set of tokens, but here's a few ideas:</p>
		<ul>
			<li>Sweet Talking (works to Charisma)</li>
			<li>Trap Disarming (works with Cunning)</li>
			<li>Bartering</li>
			<li>Tying Knots</li>
			<li>Farming</li>
			<li>Swimming</li>
			<li>Acrobatics</li>
			<li>Kissing</li>
			<li>Blowjobs</li>
			<li>Vaginal Masturbation</li>
			<li>Penile Masturbation</li>
			<li>Anal Play</li>
			<li>Riding</li>
		</ul>
		<h3>Name generation and relationship tracking</h3>
		<p>Just an idea I had.</p>
		<h4>Name generation</h4>
		<p>
			<span class="done">Remove the Dwarf Fortress name generator and dictionaries, add a simple one that combines from a set of tables.</span> That way, instead of "Caquot Seggunullung" which can translate to "Bloody Belchbuttock", you just generate something untranslatable like "Tarvim Ironfist". Generate and store the first name and surname separately. Also specify what kind of surname that culture would use so that Tarvim's direct descendant could be "Nalrimm Ironfist" or "Nalrimm Tarvimson" (patronymic style). If it's a patronym, Tarvim's surname should theoretically be either nothing at all or just another name of the same style with "-son" appended -- "Tarvim Yendurson", perhaps?
		</p>
		<p>
			Yes, that could work. For a given culture, specify the name generator patterns for males and females, and either the suffixes for patronyms ("son", "daughter" for English) or another generator pattern for surnames. If it's a patronym, descendants get the name of the parent with a suffix, and if it's not, they just get the parent's surname.
		</p>
		<p>
			Since surnames are stored separately, you could store titles as well. Tarvim Yendurson could, hypothetically, gain the "Ironfist" title...
		</p>
		<blockquote>
			<code>if (patronymic && hastitle) return firstName + " " + title //Tarvim Ironfist<br/>
			else if (hastitle) return firstName + " \"" + title + "\" " + surname //Tarvim "Ironfist" Jones<br/>
			else return firstName + " " + surname //Tarvim Yendurson</code>
		</blockquote>
		<h4>Relationship tracking</h4>
		<p>
			Given the token system, we should be able to track the relationships between any set of characters. Let's go with Tarvim's family as described above and the player. Tarvim's relationship tokens could be like this:
		</p>
		<ul>
			<li>
				Tarvim Yendurson
				<ul>
					<li>
						relations
						<ul>
							<li>
								Yendur ???
								<ul>
									<li>
										father
									</li>
								</ul>
							</li>
							<li>
								Nalrimm Tarvimson
								<ul>
									<li>
										son
									</li>
								</ul>
							</li>
							<li>
								<i>(the player)</i>
								<ul>
									<li>
										friend
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>
			For friendship and other non-blood relations, the token's value could be used to track the power of that relationship. Of course, Nalrimm can never not be Tarvim's son so the value for the "son" token is useless.
		</p>

		<h2 id="base">Home base</h2>
		<p>
			An idea I had earlier today. Since characters are capable of leaving the board and entering another one, as the player does to navigate the overworld and dungeons, why not use it to move certain characters from their source board to a special "Player's House" board? It can start out small, with a low limit on how many occupants it can have, and possibly not even in the player's possession. Then you can use your earnings to buy room extensions and beds, which increase the occupancy limit.
		</p>
		<h3>Idea #1</h3>
		<p>
			Reserving one board for the home base, probably adjacent to a town like the <a href="#bones">graveyard</a>, this would start out as just another "wild" board. Once you buy the plot, that board is replaced with a blank one, retaining only its biome. (Thought: limit home base predestination to grasslands so we can ignore biomes?) On this featureless board, a small house is constructed from an XML floor plan. The floor plan data defines several rooms, each with a specific level attribute, or perhaps grouped into level elements. Each room has a unique ID, as does all the furniture the room comes with. This allows the home base inhabitants to have assigned rooms and beds in a way not entirely unlike Dwarf Fortress, the only difference being that it's not up to the player to assign rooms &mdash; the game does that. Buying upgrades appends higher-level rooms to the existing structure, increasing the maximum amount of inhabitants.
		</p>

		<h2 id="items">Items</h2>
		<h3>Maximum carrying weight</h3>
		<p>
			Every item has a weight property; "feather", "light", "medium", "heavy" or "fuck ass heavy". These have the values {0, 1, 2, 4, 16} in order. To determine the total weight of a character's inventory, loop through all the items they carry and add up the weight values. If the carrying weight is higher than the capacity, the character is considered stuck to the floor and can't leave unless they drop something. If it's merely close to or equal, the character might fail to move each step.
		</p>
		<p>
			For example, a character with only a shirt, undies, pants and a thick stick would add up to the following total carrying weight:
		</p>
		<table>
			<tr><th>Item</th><th>Weight</th><th>Score</th></tr>
			<tr><td>Undies</td><td>feather</td><td>0</td></tr>
			<tr><td>Shirt</td><td>light</td><td>1</td></tr>
			<tr><td>Pants</td><td>light</td><td>1</td></tr>
			<tr><td>Thick stick</td><td>medium</td><td>2</td></tr>
			<tr><td>Total weight</td><td></td><td>4</td></tr>
		</table>
		<p>Now, look up the total carrying capacity, determined by the character's strength:</p>
		<table>
			<tr><th>Strength</th><th>Name</th><th>Capacity</th></tr>
			<tr><td>0</td><td>Boneless Chicken</td><td>1</td></tr>
			<tr><td>1 - 10</td><td>Picked Last at P.E.</td><td>4</td></tr>
			<tr><td>11 - 20</td><td>Average Joe</td><td>8</td></tr>
			<tr><td>21 - 40</td><td>Heavy Delivery</td><td>16</td></tr>
			<tr><td>41 - 60</td><td>Bench Press a Bench</td><td>32</td></tr>
			<tr><td>61 - 80</td><td>Olympic Gold</td><td>56</td></tr>
			<tr><td>81 - 100</td><td>Demigod</td><td>64</td></tr>
		</table>
		<p>Our example character would need at least piddling strength to wield that stick, let alone carry it with him.</p>
		<h3>Equipment</h3>
		<p class="done">Equip-able items can be linked to one or more of these slots:</p>
		<ul>
			<li>Underpants</li>
			<li>Undershirt</li>
			<li>Pants</li>
			<li>Shirt</li>
			<li>Jacket</li>
			<li>Cloak</li>
			<li>Head</li>
			<li>Hands
				<ul><li>These are for weapons. There are two of these, sharing one identifier.</li></ul>
			</li>
			<li>Fingers
				<ul><li>These are for rings. There are ten of these on one identifier, but none if you're playing a quadruped.</li></ul>
			</li>
		</ul>
		<h4>To equip an item</h4>
		<pre>
			if rings and character is quadruped, error out.
			if required slots have covering slots
				check for target slot's reachability.
				if unreachable, try to temp-remove items in covering slots, recursively.
				if still unreachable, error out.
			if required slots are taken
				try to unequip the items in those slots, recursively.
				if required slots are still taken, error out;
				else, mark the item as equipped.
			replace each temp-removed item whose required slots are still free.
		</pre>
		<h4>To remove an item</h4>
		<pre>
			if item's slots have covering slots
				check for target slot's reachability.
				if unreachable, try to temp-remove items in covering slots, recursively.
				if still unreachable, error out.
			if item is cursed, error out
			mark item as unequipped.
		</pre>
		<h4>To temporarily remove an item</h4>
		<pre>
			unequip the item, placing it in the temp-removal stack.
		</pre>
		<h4>Example of the process</h4>
		<ol>
			<li>Starting out naked</li>
			<li>Equip skirt
				<ul>
					<li>"pants" slot is free</li>
					<li>mark skirt as equipped</li>
				</ul>
			<li>Equip panties
				<ul>
					<li>"underpants" slot is free</li>
					<li>"underpants" slot is covered by "pants" slot but skirt has reach</li>
					<li>mark panties as equipped</li>
				</ul>
			</li>
			<li>Equip pants
				<ul>
					<li>"pants" slot is not free</li>
					<li>try to remove skirt</li>
					<li>skirt is no longer marked as equipped</li>
					<li>mark pants as equipped</li>
				</ul>
			</li>
			<li>Remove panties
				<ul>
					<li>"underpants" slot is covered by "pants" slot, pants don't reach</li>
					<li>try to temp-remove pants</li>
					<li>pants are no longer marked as equipped</li>
					<li>pants are memorized</li>
					<li>mark panties as unequipped</li>
					<li>replace temp-removal items</li>
					<li>pants are marked as equipped</li>
				</ul>
			</li>
			<li>Remove pants
				<ul><li><samp>You try to take off the pants, but find they are cursed!</samp></li></ul>
			</li>
			<li>Equip panties
				<li>"underpants" slot is covered by "pants" slot, pants don't reach</li>
				<li>try to temp-remove pants</li>
				<li><samp>You can't take off your pants -- they are cursed!</samp></li>
			<li>End result: cursed pants, no underwear... <b><i>FOREVER!</i></b></li>
		</ol>
		<ol>
			<li>Starting out with a coat (cloak slot) and sundress (shirt and pants slots)</li>
			<li>Remove sundress (from pants slot)
				<ul>
					<li>sundress is also on the shirt slot, which is covered by jacket</li>
					<li>jacket is covered by the cloak slot</li>
					<li>try to temp-remove coat</li>
					<li>coat is no longer marked as equipped</li>
					<li>coat is memorized</li>
					<li>mark sundress as unequipped</li>
					<li>replace temp-removal items</li>
					<li>coat is marked as equipped</li>
				</ul>
			<li>End result: coat with nothing under</li>
		</ol>
		<h4>Order of operations</h4>
		<p>
			It's better to take off your pants before taking off your underpants. Without these, you'd get "try to remove undies", "temp-remove pants", "remove undies", "replace pants"... "remove pants again!"
		</p>
		<dl>
			<dt>Getting Dressed</dt><dd>{ underpants, undershirt, pants, shirt, jacket, cloak }</dd>
			<dt>Getting Undressed:</dt><dd>{ cloak, jacket, shirt, pants, undershirt, underpants }</dd>
			<dt>Going Topless:</dt><dd>{ cloak, jacket, shirt, undershirt }</dd>
			<dt>Bare Bottom:</dt><dd>{ pants, underpants } &mdash; but watch out for things like dresses and bodysuits!</dd>
		</dl>
		<h4>Reach and Translucency</h4>
		<p class="done">
			Clothing items have a "reach" and a "translucent" flag. If "reach" is set, items in the slot directly covered by this item's slot can be interacted with without removing the other item - pants have no reach but skirts do, because you can reach under them. If "translucent" is set, items in the slot directly covered by this item's slot can be seen -- the covering item has translucent material or is very little material.
		</p>
		<p class="done">
			<strong>These properties drill down!</strong> A wet shirt shows the bra underneath, but the bra hides details about the breasts they cover, whereas a very lacy bra would allow more detailed description of the breasts, the bra and the shirt.
		</p>
		<h4>Tattoos, condoms, piercings and other similar stuff</h4>
		<p>
			Don't bother with making these equip-able - tattoos and piercings can be done as tokens instead...
		</p>
		<ul>
			<li>skin
				<ul>
					<li>light</li>
					<li>tattoo
						<ul>
							<li>tribal</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>hips
				<ul>
					<li><var>value</var></li>
					<li>tattoo
						<ul>
							<li>tramp stamp</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>breast row
				<ul>
					<li>amount
						<ul>
							<li><var>value</var></li>
						</ul>
					<li>size
						<ul>
							<li><var>value</var></li>
						</ul>
					<li>nipples
						<ul>
							<li><var>value</var></li>
							<li>piercing
								<ul>
									<li>ring</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>
			...which are then touched upon by the Look description builder, based on their visibility? Perhaps shirts and undershirts should have extra options to tell that the belly and/or arms are visible, even though they're not translucent?
		</p>
		<p>
			The same token approach can be used for condoms... and the diseases they'd otherwise prevent.
		</p>
		<h4>Swimsuits and such</h4>
		<p class="new">Equipping or removing an article of clothing that is both a shirt and pants, or undershirt and underpants, should check and affect both slots.</p>

		<h2 id="gen">World generation</h2>
		<p>Oh boy, this is it. This is the big one. How do you even begin to tackle a concept like this? Well, here's a start.</p>
		<p>
			Split it up into an overworld and dungeons, each with their own style of generation. Now, when I say "dungeons" I don't mean that in the literal sense, so keep that in mind.
		</p>
		<h3>Overworld</h3>
		<p class="scratched">
			For each biome (grassland, desert, snow, swamp), generate at least n boards, plus or minus a few, according to the biome size table. Now, pick a starting board, and (recursively?) connect four other boards of the same biome, or sometimes a "linked" biome. While connecting boards, keep track of the distance from the center. If you get too far away, don't link up any further, but rather take the current board and insert a mountainside in the relevant directions to show the world's edges. Now, scatter some towns around, preferably in the grasslands, and some dungeon entrances pretty much anywhere. Personally, I would suggest using boards.xml for the town boards. When all that is done, you can pick an appropriate location to spawn the player and cut loose.
		</p>
		<table>
			<tr><th>Biome</th><th>Size</th><th>Linked biomes</th></tr>
			<tr><td>Grassland</td><td>32</td><td>Desert, snow, swamp</td></tr>
			<tr><td>Desert</td><td>16</td><td>Grassland</td></tr>
			<tr><td>Snow</td><td>8</td><td>Swamp</td></tr>
			<tr><td>Swamp</td><td>8</td><td>Snow, grassland</td></tr>
		</table>
		<p class="done">
			On second thought, maybe not so much determine and link the boards during generation, but keep a 2D map of the world and fill that with specific biomes, then generate boards to match.
		</p>
		<p class="done">
			I'm thinking, start with a map full of grasslands, then pick a random spot to start with desert. From that spot, pick three directions at random to spread the desert to that contain grassland. If you can't get at least one of those, pick a new starting point to flow from, which has to be grassland. Repeat until you've hit sixteen spots, then do the same with snow and swamp, leaving thirty-two spots for grasslands. This ought to make the map much more random.
		</p>
		<table id="mapmockup">
			<tr><th colspan="8">Mockup</th></tr>
			<tr><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td></tr>
			<tr><td class="de">&nbsp;</td><td class="de">&#x3C0;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="de">&nbsp;</td></tr>
			<tr><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="de">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&#x3C0;</td><td class="gr">&nbsp;</td></tr>
			<tr><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&#x263A;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td></tr>
			<tr><td class="sn">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&#x3C0;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td></tr>
			<tr><td class="sn">&nbsp;</td><td class="sn">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td><td class="gr">&nbsp;</td></tr>
			<tr><td class="sn">&nbsp;</td><td class="sn">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="gr">&#x3C0;</td><td class="gr">&nbsp;</td></tr>
			<tr><td class="sn">&nbsp;</td><td class="sn">&nbsp;</td><td class="sn">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="sw">&nbsp;</td><td class="gr">&nbsp;</td></tr>
		</table>
		<p>Surprisingly, this mockup comes out to exactly the right amount of boards per biome!</p>
		<h3>Dungeons</h3>
		<p>
			Pretty much the same way any Roguelike would do it, but with not only stairs up and down but also passages to other boards on the same dungeon level. We could use edge connections here, but the twisty nature of Roguelike dungeons makes that a rather complicated mess. Generate dungeons of, say ten to twenty boards in size for each entrance on the overworld.
		</p>
		<p>
			Any board that does not contain a town should be automatically populated with appropriate encounters, to be refilled if the amount of characters is less than four or something and the player re-enters the board. Towns, being (mostly?) hand-crafted, have their inhabitants defined in the XML, anyway. Perhaps prevent killing them?
		</p>
		<h3>Things on the overworld</h3>
		<dl>
			<dt>Grassland</dt>
			<dd>Rocks, sandy patches, ponds, trees, smaller plants, tombstones</dd>
			<dt>Desert</dt>
			<dd>Cacti, skeletal remains, oasis, dead trees</dd>
			<dt>Snow</dt>
			<dd>Trees with snow on, (semi-frozen) ponds</dd>
			<dt>Swamp</dt>
			<dd>Dead trees, willows, small plants, ponds</dd>
		</dl>
		<h4 id="bones">Regarding tombstones</h4>
		<p>If there's a bones file, add a graveyard board close to a randomly chosen town. For each bones entry, add a tombstone on that board. The tombstone's inscription should be the name of the player described in that entry, and the cause of their death. If there are too many tombstones to fit on the board, start reusing old ones.</p>
		<p>Bones files should be simple flatfiles to make processing easy, but have both <a href="#gzip"><code>GZip</code> and <code>Crypto</code> streams</a> attached. If we're going with DF-style historical accounts, use encrypted XML instead of a flatfile, and offer the option to save as "pure" XML. But mind you, it's the encrypted version that's actually used by the game.</p>

		<h2 id="save">Saving and Loading</h2>
		<p>
			Boards are described by XML files right now, and depending on the world generation one header up, they might not remain so. Even so, saving and loading can be done pretty fast for an individual board and all the things on it.
			</p>
		<h3>Byte pattern per tile on a board</h3>
		<p>All 80 * 25 of them.</p>
		<table>
			<tr><td>tile number</td><td>foreground red</td><td>foreground green</td><td>foreground blue</td><td>background red</td><td>background green</td><td>background blue</td><td>settings</td><td>more settings</td><td>ExTile</td><td>burn timer</td></tr>
		</table>
		<p class="done">
			<del>The color byte is a packed CGA attribute, like in classic text mode &mdash; the colors are packed nibble-wise, so 0x19 means light-blue on navy.</del> Colors are stored as double RGB triplets.
		</p>
		<h4>Settings byte</h4>
		<table>
			<tr><th>Bit</th><th>Meaning</th></tr>
			<tr><td>1</td><td>Can burn</td></tr>
			<tr><td>2</td><td>Is solid</td></tr>
			<tr><td>3</td><td>Can fly over</td></tr>
			<tr><td>4</td><td>Has a non-zero burn timer</td></tr>
			<tr><td>5</td><td>Reserved</td></tr>
			<tr><td>6</td><td>Reserved</td></tr>
			<tr><td>7</td><td>Has an ExTile</td></tr>
			<tr><td>8</td><td>Has more settings</td></tr>
		</table>
		<h4>More Settings byte</h4>
		<table>
			<tr><th>Bit</th><th>Meaning</th></tr>
			<tr><td>1</td><td>Reserved</td></tr>
			<tr><td>2</td><td>Reserved</td></tr>
			<tr><td>3</td><td>Reserved</td></tr>
			<tr><td>4</td><td>Reserved</td></tr>
			<tr><td>5</td><td>Reserved</td></tr>
			<tr><td>6</td><td>Reserved</td></tr>
			<tr><td>7</td><td>Reserved</td></tr>
			<tr><td>8</td><td>Reserved</td></tr>
		</table>
		<p class="done">
			The "more settings" byte, ExTile number and burn timer are not stored at all if their respective bits in the settings byte aren't set. What "more settings" entails is undefined as of yet, and ExTiles for board tiles aren't supported yet because they can't be defined just yet. So basically a tile is at least <del>three</del> eight bytes long, and at most <del>six</del> eleven bytes, storing only the required stuff.
		</p>
		<p id="gzip" class="done">
			The beauty of .Net streams is that you could open a file for saving, hook up a <code>BinaryWriter</code> to save a header, and then replace that <code>BinaryWriter</code> with a <code>CryptoStream</code>, hook a <code>GZipStream</code> up to that and a fresh <code>BinaryWriter</code> at the end, and then call <code>World.SaveToFile(thatStream)</code>. Why is this so nice? Because it lets you specify things in the header in a reasonably readable format, such as an identifying cookie, the world's name, some version info and whether or not it's compressed and/or encrypted, so you can hook up the <code>Crypto</code>- and <code>GZipStream</code> objects only when needed!
		</p>
		<p>
			Incidentally, <code>CryptoStream</code> is something I made to practice this shit on &mdash; it flips all high bits.
		</p>
		<p class="done">
			So, to bind all that together, once the world has taken its time to convert/generate, it should be saved in binary only, with the user specifying if it should be zipped up.
		</p>

		<h2 id="units">Units of Measurement</h2>
		<h3>Lengths and Widths</h3>
		<p>These are straight up centimeters. We have to use centimeters because the roll meta-tag only does integers.</p>
		<h3>Breasts</h3>
		<p>These are based on inches exclusively because breast measurements are <samp>incredibly silly</samp>.</p>
		<table>
			<tr><th>Inches</th><th>Visual(s)</th><th>Cup</th><th>&nbsp;</th></tr>
			<tr><td>0.0</td><td>flat</td><td>&nbsp;</td><td>&nbsp;</td></tr>
			<tr><td>0.1 - 0.4</td><td>tiny</td><td>AA</td><td>Hinnyuu</td></tr>
			<tr><td>0.5 - 0.9</td><td>small</td><td>A</td><td>&nbsp;</td></tr>
			<tr><td>1.0 - 2.4</td><td>fair</td><td>B</td><td>Funyuu</td></tr>
			<tr><td>2.5 - 3.4</td><td>appreciable</td><td>C</td><td>&nbsp;</td></tr>
			<tr><td>3.5 - 4.4</td><td>ample</td><td>D</td><td>&nbsp;</td></tr>
			<tr><td>4.5 - 5.9</td><td>pillowy</td><td>E</td><td>Kyonyuu</td></tr>
			<tr><td>6.0 - 6.9</td><td>large</td><td>F</td><td>&nbsp;</td></tr>
			<tr><td>7.0 - 7.9</td><td>ridiculously large</td><td>G</td><td>&nbsp;</td></tr>
			<tr><td>8.0 - 8.9</td><td>huge</td><td>H</td><td>Bakunyuu (also, H is for Huge)</td></tr>
			<tr><td>9.0 - 9.9</td><td>spacious</td><td>I</td><td>&nbsp;</td></tr>
			<tr><td>10 - 11.9</td><td>back-breaking</td><td>J</td><td>&nbsp;</td></tr>
			<tr><td>12 - 12.9</td><td>mountainous</td><td>K</td><td>&nbsp;</td></tr>
			<tr><td>13 - 13.9</td><td>ludicrous</td><td>L</td><td rowspan="2">Thanks to Hammy</td></tr>
			<tr><td>14 - 14.9</td><td>exploding</td><td>M</td></tr>
			<tr><td>15 - &infin;</td><td>absurdly huge</td><td>&nbsp;</td><td>&nbsp;</td></tr>
		</table>
		<p>
			Tiny titties are always referred to as such, but no other size is allowed to alliterate. When supposed to give cup sizes, we could extrapolate up to Z, algorithmically. Incidentally, these cup sizes are Japan/EU measurements. Chounyuu rating would be N-cup and higher.
		</p>
		<h3>Hips</h3>
		<table>
			<tr><th>Rating</th><th>Visual(s)</th></tr>
			<tr><td>0 - 0.9</td><td>tiny, boyish</td></tr>
			<tr><td>1 - 3.9</td><td>slender, narrow, thin</td></tr>
			<tr><td>4 - 5.9</td><td>average, normal, plain</td></tr>
			<tr><td>6 - 9.9</td><td>ample, noticeable, girly</td></tr>
			<tr><td>10 - 14.9</td><td>flared, curvy, wide</td></tr>
			<tr><td>15 - 19.9</td><td>fertile, child-bearing, voluptuous</td></tr>
			<tr><td>20 - &infin;</td><td>broodmother-sized, cow-like, inhumanly wide</td></tr>
		</table>
		<p>If the butt rating is lower than 6, hip ratings up to 3.9 are always "waspish".</p>
		<h3>Butts</h3>
		<table>
			<tr><th>Rating</th><th>Visual(s)</th></tr>
			<tr><td>0 - 0.9</td><td>very small, insignificant</td></tr>
			<tr><td>1 - 3.9</td><td>tight, firm, compact</td></tr>
			<tr><td>4 - 5.9</td><td>regular, unremarkable</td></tr>
			<tr><td>6 - 7.9</td><td>handful of ass, full, shapely</td></tr>
			<tr><td>8 - 9.9</td><td>squeezable, large, substantial</td></tr>
			<tr><td>10 - 12.9</td><td>jiggling, spacious, heavy</td></tr>
			<tr><td>13 - 15.9</td><td>expansive, generous amount of ass, voluminous</td></tr>
			<tr><td>16 - 19.9</td><td>huge, vast, jiggling expanse of ass</td></tr>
			<tr><td>20 - &infin;</td><td>ginormous, colossal, tremendous</td></tr>
		</table>
		<p>If it ends in "of ass", don't add a random synonym for "butt".</p>
		<h3>Balls</h3>
		<table>
			<tr><th>Rating</th><th>Visual(s)</th></tr>
			<tr><td>0 - 0.9</td><td>[none]</td></tr>
			<tr><td>1 - 1.9</td><td>large</td></tr>
			<tr><td>2 - 2.9</td><td>baseball-sized</td></tr>
			<tr><td>3 - 3.9</td><td>apple-sized</td></tr>
			<tr><td>4 - 4.9</td><td>grapefruit-sized</td></tr>
			<tr><td>5 - 6.9</td><td>cantaloupe-sized</td></tr>
			<tr><td>7 - 8.9</td><td>soccer ball-sized</td></tr>
			<tr><td>9 - 11.9</td><td>basketball-sized</td></tr>
			<tr><td>12 - 14.9</td><td>watermelon-sized</td></tr>
			<tr><td>15 - 17.9</td><td>beach ball-sized</td></tr>
			<tr><td>18 - &infin;</td><td>hideously swollen and oversized</td></tr>
		</table>
		<h3>Hair</h3>
		<table>
			<tr><th>Rating</th><th>Visual(s)</th></tr>
			<tr><td>0</td><td>bald, shaved</td></tr>
			<tr><td>0.1 - 0.9</td><td>trim, close-cropped</td></tr>
			<tr><td>1 - 2.9</td><td>short</td></tr>
			<tr><td>3 - 5.9</td><td>shaggy</td></tr>
			<tr><td>6 - 9.9</td><td>moderately long</td></tr>
			<tr><td>10 - 15.9</td><td>shoulder-length, long</td></tr>
			<tr><td>16 - 25.9</td><td>flowing locks of, very long</td></tr>
			<tr><td>26 - 39.9</td><td>ass-length</td></tr>
			<tr><td>40 - &infin;</td><td>obscenely long</td></tr>
		</table>
		<h3>Waists</h3>
		<p>Thanks to Hammy for these.</p>
		<table>
			<tr><th>Rating</th><th>Visual(s)</th></tr>
			<tr><td>0 - 0.9</td><td>emaciated, gaunt</td></tr>
			<tr><td>1 - 3.9</td><td>thin, athletic</td></tr>
			<tr><td>4 - 5.9</td><td>normal, average</td></tr>
			<tr><td>6 - 7.9</td><td>soft, spongy</td></tr>
			<tr><td>8 - 10.9</td><td>chubby, grope-able</td></tr>
			<tr><td>11 - 13.9</td><td>plump, meaty</td></tr>
			<tr><td>14 - 16.9</td><td>corpulent, stout</td></tr>
			<tr><td>17 - 19.9</td><td>obese, rotund</td></tr>
			<tr><td>20 - &infin;</td><td>morbid, immobilizing</td></tr>
		</table>
		<h3>Looseness</h3>
		<p>This one is integer only.</p>
		<table>
			<tr><th>Rating</th><th>Vaginas</th><th>Butts</th></tr>
			<tr><td>0</td><td>virgin</td><td>virgin</td></tr>
			<tr><td>1</td><td>tight</td><td>tight</td></tr>
			<tr><td>2</td><td>[none]</td><td>[none]</td></tr>
			<tr><td>3</td><td>loose</td><td>loose</td></tr>
			<tr><td>4</td><td>very loose</td><td>stretched</td></tr>
			<tr><td>5</td><td>gaping</td><td>distented</td></tr>
			<tr><td>6</td><td>gaping wide</td><td>gaping</td></tr>
			<tr><td>7</td><td>cavernous</td><td>cavernous</td></tr>
		</table>

	</body>
</html>